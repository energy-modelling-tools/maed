name: Update YAML File with Images

on:
  issues:
    types: [edited]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-yml:
    runs-on: ubuntu-latest
    steps:
      - name: Check and parse YAML issue
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels || [];
            const labelNames = labels.map(l => l.name);
            console.log('Issue labels:', labelNames);
            
            const body = context.payload.issue.body || '';
            console.log('Issue body length:', body.length);
            
            // Check if this is a yml-edit issue
            const hasYmlEdit = labelNames.includes('yml-edit');
            const hasYamlFileField = body.includes('Which YAML file do you want to edit');
            
            if (!hasYmlEdit && !hasYamlFileField) {
              console.log('Skipping: not a yml-edit issue');
              core.setOutput('should_run', 'false');
              return;
            }
            
            // Extract YAML file path
            const filePatterns = [
              /###\s*Which YAML file do you want to edit\?\s*\n\s*([^\n]+)/i,
              /###\s*Which YAML file do you want to edit\?\s*\n\n\s*([^\n]+)/i,
              /Prefilled YAML Content from `([^`]+)`/i,
              /Prefilled Content from `([^`]+)`/i
            ];
            
            let filePath = null;
            for (const pattern of filePatterns) {
              const match = body.match(pattern);
              if (match && match[1]) {
                filePath = match[1].trim();
                // Ensure it's a YAML file
                if (filePath.endsWith('.yml') || filePath.endsWith('.yaml')) {
                  break;
                }
              }
            }
            
            // Extract YAML content from the code block or YAML Content field
            const yamlMatch = body.match(/```yaml\s*\n([\s\S]*?)\n```/);
            // Also check for YAML content in the YAML Content field from the form
            const yamlContentFieldMatch = body.match(/###\s*YAML Content\s*\n\s*```yaml\s*\n([\s\S]*?)\n```/i) || 
                                         body.match(/###\s*YAML Content\s*\n\n\s*```yaml\s*\n([\s\S]*?)\n```/i);
            const newContent = yamlMatch ? yamlMatch[1] : (yamlContentFieldMatch ? yamlContentFieldMatch[1].trim() : null);
            
            // Extract image URLs from the issue
            const imageUrls = [];
            // Match Markdown image format: ![alt](url)
            const imagePattern = /!\[.*?\]\((https?:\/\/[^\s\)]+\.(jpg|jpeg|png|gif|svg|webp))\)/gi;
            let imageMatch;
            while ((imageMatch = imagePattern.exec(body)) !== null) {
              imageUrls.push(imageMatch[1]);
            }
            // Match GitHub automatically uploaded images
            const githubImagePattern = /https:\/\/user-images\.githubusercontent\.com\/[^\s\)]+/g;
            const githubImages = body.match(githubImagePattern) || [];
            imageUrls.push(...githubImages);
            
            if (!filePath) {
              console.error('No YAML file path found');
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: '❌ Cannot find YAML file path in issue. Please make sure the format is correct.'
              });
              core.setOutput('should_run', 'false');
              return;
            }
            
            if (!newContent) {
              console.error('No YAML content found');
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: '❌ Cannot find YAML content. Please make sure to edit the content in the yaml code block.'
              });
              core.setOutput('should_run', 'false');
              return;
            }
            
            console.log('✅ YAML file path:', filePath);
            console.log('✅ YAML content length:', newContent.length);
            console.log('✅ Found images:', imageUrls.length);
            
            core.setOutput('filePath', filePath);
            core.setOutput('yamlContent', newContent);
            core.setOutput('imageUrls', JSON.stringify(imageUrls));
            core.setOutput('should_run', 'true');

      - name: Checkout repository
        if: steps.parse.outputs.should_run == 'true'
        uses: actions/checkout@v4

      - name: Download and save images
        if: steps.parse.outputs.should_run == 'true' && steps.parse.outputs.imageUrls != '[]'
        id: images
        env:
          IMAGE_URLS: ${{ steps.parse.outputs.imageUrls }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const https = require('https');
            const http = require('http');
            
            const imageUrls = JSON.parse(process.env.IMAGE_URLS || '[]');
            const savedImages = [];
            
            for (const imageUrl of imageUrls) {
              try {
                // Extract the file name from the URL
                const urlParts = imageUrl.split('/');
                let fileName = urlParts[urlParts.length - 1].split('?')[0];
                
                // If there is no extension, try to infer the extension from the URL
                if (!fileName.match(/\.(jpg|jpeg|png|gif|svg|webp)$/i)) {
                  // Check if the URL has extension information
                  const urlExtMatch = imageUrl.match(/\.(jpg|jpeg|png|gif|svg|webp)/i);
                  if (urlExtMatch) {
                    fileName = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}${urlExtMatch[0]}`;
                  } else {
                    fileName = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.png`;
                  }
                }
                
                // Determine the save path (assets/img/)
                const saveDir = 'assets/img';
                if (!fs.existsSync(saveDir)) {
                  fs.mkdirSync(saveDir, { recursive: true });
                }
                
                const savePath = path.join(saveDir, fileName);
                
                // Download the image
                const protocol = imageUrl.startsWith('https') ? https : http;
                await new Promise((resolve, reject) => {
                  const request = protocol.get(imageUrl, (response) => {
                    if (response.statusCode === 200 || response.statusCode === 301 || response.statusCode === 302) {
                      // Handle the redirection
                      if (response.statusCode === 301 || response.statusCode === 302) {
                        const redirectUrl = response.headers.location;
                        if (redirectUrl) {
                          const redirectProtocol = redirectUrl.startsWith('https') ? https : http;
                          redirectProtocol.get(redirectUrl, (redirectResponse) => {
                            const fileStream = fs.createWriteStream(savePath);
                            redirectResponse.pipe(fileStream);
                            fileStream.on('finish', () => {
                              fileStream.close();
                              console.log(`✅ Downloaded: ${savePath}`);
                              savedImages.push(`/${savePath}`);
                              resolve();
                            });
                          }).on('error', reject);
                          return;
                        }
                      }
                      
                      const fileStream = fs.createWriteStream(savePath);
                      response.pipe(fileStream);
                      fileStream.on('finish', () => {
                        fileStream.close();
                        console.log(`✅ Downloaded: ${savePath}`);
                        savedImages.push(`/${savePath}`);
                        resolve();
                      });
                    } else {
                      reject(new Error(`Failed to download: ${response.statusCode}`));
                    }
                  });
                  request.on('error', reject);
                });
              } catch (err) {
                console.error(`❌ Failed to download ${imageUrl}:`, err.message);
              }
            }
            
            core.setOutput('saved_paths', JSON.stringify(savedImages));
            core.setOutput('count', savedImages.length.toString());

      - name: Update YAML file
        if: steps.parse.outputs.should_run == 'true'
        env:
          FILE_PATH: ${{ steps.parse.outputs.filePath }}
          YAML_CONTENT: ${{ steps.parse.outputs.yamlContent }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const filePath = process.env.FILE_PATH;
            const yamlContent = process.env.YAML_CONTENT;
            
            // Ensure the directory exists
            const dir = path.dirname(filePath);
            if (!fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
            
            // Write YAML content directly (no front matter processing needed)
            fs.writeFileSync(filePath, yamlContent, 'utf8');
            console.log(`✅ YAML file updated: ${filePath}`);

      - name: Create Pull Request
        if: steps.parse.outputs.should_run == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "Update ${{ steps.parse.outputs.filePath }} via issue #${{ github.event.issue.number }}"
          title: "Update ${{ steps.parse.outputs.filePath }}"
          body: |
            This PR was automatically created from issue #${{ github.event.issue.number }}.
            
            **Changes:**
            - Updated `${{ steps.parse.outputs.filePath }}`
            ${{ steps.images.outputs.count && steps.images.outputs.count != '0' && format('- Added {0} image(s) to assets/img/', steps.images.outputs.count) || '' }}
            
            Please review and merge if everything looks good.
            
            ---
            Closes #${{ github.event.issue.number }}
          branch: "yml-edit-issue-${{ github.event.issue.number }}"
          delete-branch: true
          labels: yml-edit

